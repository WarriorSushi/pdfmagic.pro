"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/pdf-utils.ts":
/*!******************************!*\
  !*** ./src/lib/pdf-utils.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectCoverPages: function() { return /* binding */ detectCoverPages; },\n/* harmony export */   exportPDF: function() { return /* binding */ exportPDF; },\n/* harmony export */   processPDFFile: function() { return /* binding */ processPDFFile; },\n/* harmony export */   renderPDFPageHighRes: function() { return /* binding */ renderPDFPageHighRes; }\n/* harmony export */ });\n/* harmony import */ var react_pdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-pdf */ \"(app-pages-browser)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.mjs\");\n\n// Configure PDF.js worker to match react-pdf's internal pdfjs-dist@5.3.93\nreact_pdf__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.mjs\";\nasync function processPDFFile(file) {\n    try {\n        console.log(\"Processing PDF:\", file.name, \"Size:\", file.size, \"Type:\", file.type);\n        const arrayBuffer = await file.arrayBuffer();\n        console.log(\"ArrayBuffer size:\", arrayBuffer.byteLength);\n        const pdf = await react_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            // Enhanced compatibility options\n            verbosity: 0,\n            cMapUrl: \"https://unpkg.com/pdfjs-dist@3.11.174/cmaps/\",\n            cMapPacked: true,\n            standardFontDataUrl: \"https://unpkg.com/pdfjs-dist@3.11.174/standard_fonts/\",\n            // Handle corrupted PDFs\n            stopAtErrors: false,\n            maxImageSize: 1024 * 1024 * 50,\n            disableFontFace: false,\n            disableRange: false,\n            disableStream: false\n        }).promise;\n        console.log(\"PDF loaded successfully. Pages:\", pdf.numPages);\n        const pages = [];\n        for(let i = 1; i <= pdf.numPages; i++){\n            try {\n                console.log(\"Processing page \".concat(i, \"/\").concat(pdf.numPages));\n                const page = await pdf.getPage(i);\n                const viewport = page.getViewport({\n                    scale: 0.5\n                });\n                const canvas = document.createElement(\"canvas\");\n                const context = canvas.getContext(\"2d\");\n                canvas.height = viewport.height;\n                canvas.width = viewport.width;\n                await page.render({\n                    canvasContext: context,\n                    viewport: viewport,\n                    // Enhanced rendering options for compatibility\n                    intent: \"display\",\n                    transform: null,\n                    background: \"white\"\n                }).promise;\n                const thumbnail = canvas.toDataURL(\"image/jpeg\", 0.8);\n                pages.push({\n                    id: \"page-\".concat(i),\n                    pageNumber: i,\n                    thumbnail,\n                    isSelected: false,\n                    isCover: i <= 3 // Mark first 3 pages as potential covers\n                });\n            } catch (pageError) {\n                console.warn(\"Failed to process page \".concat(i, \":\"), pageError);\n                // Create a placeholder page for failed pages\n                pages.push({\n                    id: \"page-\".concat(i),\n                    pageNumber: i,\n                    thumbnail: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkVycm9yIExvYWRpbmcgUGFnZTwvdGV4dD48L3N2Zz4=\",\n                    isSelected: false,\n                    isCover: i <= 3\n                });\n            }\n        }\n        console.log(\"Successfully processed\", pages.length, \"pages\");\n        return {\n            id: \"doc-\".concat(Date.now()),\n            name: file.name,\n            file,\n            pages,\n            totalPages: pdf.numPages\n        };\n    } catch (error) {\n        console.error(\"Failed to process PDF file:\", error);\n        throw new Error(\"Failed to load PDF: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n    }\n}\nfunction detectCoverPages(pages) {\n    // Simple heuristic: first 1-3 pages are likely covers\n    return pages.filter((page, index)=>index < 3).map((page)=>page.id);\n}\n// Render a specific PDF page at high resolution for editing\nasync function renderPDFPageHighRes(file, pageNumber) {\n    let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    try {\n        const arrayBuffer = await file.arrayBuffer();\n        const pdf = await react_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            verbosity: 0,\n            stopAtErrors: false\n        }).promise;\n        const page = await pdf.getPage(pageNumber);\n        const viewport = page.getViewport({\n            scale\n        });\n        const canvas = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        canvas.height = viewport.height;\n        canvas.width = viewport.width;\n        await page.render({\n            canvasContext: context,\n            viewport: viewport,\n            intent: \"display\",\n            background: \"white\"\n        }).promise;\n        return canvas.toDataURL(\"image/png\", 1.0);\n    } catch (error) {\n        console.error(\"Failed to render high-res page:\", error);\n        // Return a placeholder image\n        return \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAwIiBoZWlnaHQ9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjlmYWZiIiBzdHJva2U9IiNlNWU3ZWIiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM2Yjc0ODUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5FcnJvciBMb2FkaW5nIFBhZ2U8L3RleHQ+PC9zdmc+\";\n    }\n}\nasync function exportPDF(document1, selectedPages) {\n    try {\n        if (selectedPages.length === 0) {\n            // No pages selected, return original file\n            return new Blob([\n                await document1.file.arrayBuffer()\n            ], {\n                type: \"application/pdf\"\n            });\n        }\n        // Import pdf-lib for PDF manipulation\n        const { PDFDocument: PDFLibDocument } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! pdf-lib */ \"(app-pages-browser)/./node_modules/pdf-lib/es/index.js\"));\n        // Load the original PDF\n        const existingPdfBytes = await document1.file.arrayBuffer();\n        const pdfDoc = await PDFLibDocument.load(existingPdfBytes);\n        // Create a new PDF with only selected pages\n        const newPdf = await PDFLibDocument.create();\n        // Get page numbers from selected page IDs\n        const selectedPageNumbers = selectedPages.map((pageId)=>{\n            const page = document1.pages.find((p)=>p.id === pageId);\n            return page ? page.pageNumber - 1 : -1 // Convert to 0-based index\n            ;\n        }).filter((num)=>num >= 0).sort((a, b)=>a - b);\n        // Copy selected pages to new PDF\n        const copiedPages = await newPdf.copyPages(pdfDoc, selectedPageNumbers);\n        copiedPages.forEach((page)=>newPdf.addPage(page));\n        // Save the new PDF\n        const pdfBytes = await newPdf.save();\n        return new Blob([\n            pdfBytes\n        ], {\n            type: \"application/pdf\"\n        });\n    } catch (error) {\n        console.error(\"Failed to export PDF:\", error);\n        // Fallback: return original file\n        return new Blob([\n            await document1.file.arrayBuffer()\n        ], {\n            type: \"application/pdf\"\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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akY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3BkZi11dGlscy50cz9iMzQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBkZmpzIH0gZnJvbSAncmVhY3QtcGRmJ1xuaW1wb3J0IHsgUERGRG9jdW1lbnQsIFBERlBhZ2UgfSBmcm9tICdAL3N0b3Jlcy9wZGYtc3RvcmUnXG5cbi8vIENvbmZpZ3VyZSBQREYuanMgd29ya2VyIHRvIG1hdGNoIHJlYWN0LXBkZidzIGludGVybmFsIHBkZmpzLWRpc3RANS4zLjkzXG5wZGZqcy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9ICcvcGRmLndvcmtlci5taW4ubWpzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1BERkZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8UERGRG9jdW1lbnQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBQREY6JywgZmlsZS5uYW1lLCAnU2l6ZTonLCBmaWxlLnNpemUsICdUeXBlOicsIGZpbGUudHlwZSlcbiAgICBcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKVxuICAgIGNvbnNvbGUubG9nKCdBcnJheUJ1ZmZlciBzaXplOicsIGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgXG4gICAgY29uc3QgcGRmID0gYXdhaXQgcGRmanMuZ2V0RG9jdW1lbnQoeyBcbiAgICAgIGRhdGE6IGFycmF5QnVmZmVyLFxuICAgICAgLy8gRW5oYW5jZWQgY29tcGF0aWJpbGl0eSBvcHRpb25zXG4gICAgICB2ZXJib3NpdHk6IDAsIC8vIFJlZHVjZSBjb25zb2xlIHNwYW1cbiAgICAgIGNNYXBVcmw6ICdodHRwczovL3VucGtnLmNvbS9wZGZqcy1kaXN0QDMuMTEuMTc0L2NtYXBzLycsXG4gICAgICBjTWFwUGFja2VkOiB0cnVlLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogJ2h0dHBzOi8vdW5wa2cuY29tL3BkZmpzLWRpc3RAMy4xMS4xNzQvc3RhbmRhcmRfZm9udHMvJyxcbiAgICAgIC8vIEhhbmRsZSBjb3JydXB0ZWQgUERGc1xuICAgICAgc3RvcEF0RXJyb3JzOiBmYWxzZSxcbiAgICAgIG1heEltYWdlU2l6ZTogMTAyNCAqIDEwMjQgKiA1MCwgLy8gNTBNQiBtYXggaW1hZ2Ugc2l6ZVxuICAgICAgZGlzYWJsZUZvbnRGYWNlOiBmYWxzZSxcbiAgICAgIGRpc2FibGVSYW5nZTogZmFsc2UsXG4gICAgICBkaXNhYmxlU3RyZWFtOiBmYWxzZVxuICAgIH0pLnByb21pc2VcbiAgICBcbiAgICBjb25zb2xlLmxvZygnUERGIGxvYWRlZCBzdWNjZXNzZnVsbHkuIFBhZ2VzOicsIHBkZi5udW1QYWdlcylcbiAgXG4gICAgY29uc3QgcGFnZXM6IFBERlBhZ2VbXSA9IFtdXG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcGRmLm51bVBhZ2VzOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIHBhZ2UgJHtpfS8ke3BkZi5udW1QYWdlc31gKVxuICAgICAgICBjb25zdCBwYWdlID0gYXdhaXQgcGRmLmdldFBhZ2UoaSlcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDAuNSB9KVxuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIVxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHZpZXdwb3J0LndpZHRoXG4gICAgICAgIFxuICAgICAgICBhd2FpdCBwYWdlLnJlbmRlcih7XG4gICAgICAgICAgY2FudmFzQ29udGV4dDogY29udGV4dCxcbiAgICAgICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICAgICAgLy8gRW5oYW5jZWQgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICBpbnRlbnQ6ICdkaXNwbGF5JyxcbiAgICAgICAgICB0cmFuc2Zvcm06IG51bGwsXG4gICAgICAgICAgYmFja2dyb3VuZDogJ3doaXRlJ1xuICAgICAgICB9KS5wcm9taXNlXG4gICAgICAgIFxuICAgICAgICBjb25zdCB0aHVtYm5haWwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC44KVxuICAgICAgICBcbiAgICAgICAgcGFnZXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGBwYWdlLSR7aX1gLFxuICAgICAgICAgIHBhZ2VOdW1iZXI6IGksXG4gICAgICAgICAgdGh1bWJuYWlsLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGlzQ292ZXI6IGkgPD0gMyAvLyBNYXJrIGZpcnN0IDMgcGFnZXMgYXMgcG90ZW50aWFsIGNvdmVyc1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKHBhZ2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwcm9jZXNzIHBhZ2UgJHtpfTpgLCBwYWdlRXJyb3IpXG4gICAgICAgIC8vIENyZWF0ZSBhIHBsYWNlaG9sZGVyIHBhZ2UgZm9yIGZhaWxlZCBwYWdlc1xuICAgICAgICBwYWdlcy5wdXNoKHtcbiAgICAgICAgICBpZDogYHBhZ2UtJHtpfWAsXG4gICAgICAgICAgcGFnZU51bWJlcjogaSxcbiAgICAgICAgICB0aHVtYm5haWw6ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNakF3SWlCb1pXbG5hSFE5SWpJNE1DSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjbVZqZENCM2FXUjBhRDBpTVRBd0pTSWdhR1ZwWjJoMFBTSXhNREFsSWlCbWFXeHNQU0lqWmpObU5HWTJJaTgrUEhSbGVIUWdlRDBpTlRBbElpQjVQU0kxTUNVaUlHWnZiblF0Wm1GdGFXeDVQU0pCY21saGJDSWdabTl1ZEMxemFYcGxQU0l4TkNJZ1ptbHNiRDBpSXpZMk56TTROU0lnZEdWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJZ1pIazlJaTR6WlcwaVBrVnljbTl5SUV4dllXUnBibWNnVUdGblpUd3ZkR1Y0ZEQ0OEwzTjJaejQ9JyxcbiAgICAgICAgICBpc1NlbGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBpc0NvdmVyOiBpIDw9IDNcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgcHJvY2Vzc2VkJywgcGFnZXMubGVuZ3RoLCAncGFnZXMnKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBpZDogYGRvYy0ke0RhdGUubm93KCl9YCxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIGZpbGUsXG4gICAgICBwYWdlcyxcbiAgICAgIHRvdGFsUGFnZXM6IHBkZi5udW1QYWdlc1xuICAgIH1cbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBQREYgZmlsZTonLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIFBERjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RDb3ZlclBhZ2VzKHBhZ2VzOiBQREZQYWdlW10pOiBzdHJpbmdbXSB7XG4gIC8vIFNpbXBsZSBoZXVyaXN0aWM6IGZpcnN0IDEtMyBwYWdlcyBhcmUgbGlrZWx5IGNvdmVyc1xuICByZXR1cm4gcGFnZXNcbiAgICAuZmlsdGVyKChwYWdlLCBpbmRleCkgPT4gaW5kZXggPCAzKVxuICAgIC5tYXAocGFnZSA9PiBwYWdlLmlkKVxufVxuXG4vLyBSZW5kZXIgYSBzcGVjaWZpYyBQREYgcGFnZSBhdCBoaWdoIHJlc29sdXRpb24gZm9yIGVkaXRpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5kZXJQREZQYWdlSGlnaFJlcyhmaWxlOiBGaWxlLCBwYWdlTnVtYmVyOiBudW1iZXIsIHNjYWxlOiBudW1iZXIgPSAyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKVxuICAgIGNvbnN0IHBkZiA9IGF3YWl0IHBkZmpzLmdldERvY3VtZW50KHsgXG4gICAgICBkYXRhOiBhcnJheUJ1ZmZlcixcbiAgICAgIHZlcmJvc2l0eTogMCxcbiAgICAgIHN0b3BBdEVycm9yczogZmFsc2VcbiAgICB9KS5wcm9taXNlXG4gICAgXG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHBkZi5nZXRQYWdlKHBhZ2VOdW1iZXIpXG4gICAgY29uc3Qgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGUgfSlcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSFcbiAgICBjYW52YXMuaGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0XG4gICAgY2FudmFzLndpZHRoID0gdmlld3BvcnQud2lkdGhcbiAgICBcbiAgICBhd2FpdCBwYWdlLnJlbmRlcih7XG4gICAgICBjYW52YXNDb250ZXh0OiBjb250ZXh0LFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgaW50ZW50OiAnZGlzcGxheScsXG4gICAgICBiYWNrZ3JvdW5kOiAnd2hpdGUnXG4gICAgfSkucHJvbWlzZVxuICAgIFxuICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnLCAxLjApXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciBoaWdoLXJlcyBwYWdlOicsIGVycm9yKVxuICAgIC8vIFJldHVybiBhIHBsYWNlaG9sZGVyIGltYWdlXG4gICAgcmV0dXJuICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlOakF3SWlCb1pXbG5hSFE5SWpnd01DSWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklqNDhjbVZqZENCM2FXUjBhRDBpTVRBd0pTSWdhR1ZwWjJoMFBTSXhNREFsSWlCbWFXeHNQU0lqWmpsbVlXWmlJaUJ6ZEhKdmEyVTlJaU5sTldVM1pXSWlJSE4wY205clpTMTNhV1IwYUQwaU1pSXZQangwWlhoMElIZzlJalV3SlNJZ2VUMGlOVEFsSWlCbWIyNTBMV1poYldsc2VUMGlRWEpwWVd3aUlHWnZiblF0YzJsNlpUMGlNalFpSUdacGJHdzlJaU0yWWpjME9EVWlJSFJsZUhRdFlXNWphRzl5UFNKdGFXUmtiR1VpSUdSNVBTSXVNMlZ0SWo1RmNuSnZjaUJNYjJGa2FXNW5JRkJoWjJVOEwzUmxlSFErUEM5emRtYysnXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydFBERihkb2N1bWVudDogUERGRG9jdW1lbnQsIHNlbGVjdGVkUGFnZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxCbG9iPiB7XG4gIHRyeSB7XG4gICAgaWYgKHNlbGVjdGVkUGFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBObyBwYWdlcyBzZWxlY3RlZCwgcmV0dXJuIG9yaWdpbmFsIGZpbGVcbiAgICAgIHJldHVybiBuZXcgQmxvYihbYXdhaXQgZG9jdW1lbnQuZmlsZS5hcnJheUJ1ZmZlcigpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vcGRmJyB9KVxuICAgIH1cblxuICAgIC8vIEltcG9ydCBwZGYtbGliIGZvciBQREYgbWFuaXB1bGF0aW9uXG4gICAgY29uc3QgeyBQREZEb2N1bWVudDogUERGTGliRG9jdW1lbnQgfSA9IGF3YWl0IGltcG9ydCgncGRmLWxpYicpXG4gICAgXG4gICAgLy8gTG9hZCB0aGUgb3JpZ2luYWwgUERGXG4gICAgY29uc3QgZXhpc3RpbmdQZGZCeXRlcyA9IGF3YWl0IGRvY3VtZW50LmZpbGUuYXJyYXlCdWZmZXIoKVxuICAgIGNvbnN0IHBkZkRvYyA9IGF3YWl0IFBERkxpYkRvY3VtZW50LmxvYWQoZXhpc3RpbmdQZGZCeXRlcylcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgUERGIHdpdGggb25seSBzZWxlY3RlZCBwYWdlc1xuICAgIGNvbnN0IG5ld1BkZiA9IGF3YWl0IFBERkxpYkRvY3VtZW50LmNyZWF0ZSgpXG4gICAgXG4gICAgLy8gR2V0IHBhZ2UgbnVtYmVycyBmcm9tIHNlbGVjdGVkIHBhZ2UgSURzXG4gICAgY29uc3Qgc2VsZWN0ZWRQYWdlTnVtYmVycyA9IHNlbGVjdGVkUGFnZXNcbiAgICAgIC5tYXAocGFnZUlkID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IGRvY3VtZW50LnBhZ2VzLmZpbmQocCA9PiBwLmlkID09PSBwYWdlSWQpXG4gICAgICAgIHJldHVybiBwYWdlID8gcGFnZS5wYWdlTnVtYmVyIC0gMSA6IC0xIC8vIENvbnZlcnQgdG8gMC1iYXNlZCBpbmRleFxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIobnVtID0+IG51bSA+PSAwKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgIFxuICAgIC8vIENvcHkgc2VsZWN0ZWQgcGFnZXMgdG8gbmV3IFBERlxuICAgIGNvbnN0IGNvcGllZFBhZ2VzID0gYXdhaXQgbmV3UGRmLmNvcHlQYWdlcyhwZGZEb2MsIHNlbGVjdGVkUGFnZU51bWJlcnMpXG4gICAgY29waWVkUGFnZXMuZm9yRWFjaChwYWdlID0+IG5ld1BkZi5hZGRQYWdlKHBhZ2UpKVxuICAgIFxuICAgIC8vIFNhdmUgdGhlIG5ldyBQREZcbiAgICBjb25zdCBwZGZCeXRlcyA9IGF3YWl0IG5ld1BkZi5zYXZlKClcbiAgICByZXR1cm4gbmV3IEJsb2IoW3BkZkJ5dGVzXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vcGRmJyB9KVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBleHBvcnQgUERGOicsIGVycm9yKVxuICAgIC8vIEZhbGxiYWNrOiByZXR1cm4gb3JpZ2luYWwgZmlsZVxuICAgIHJldHVybiBuZXcgQmxvYihbYXdhaXQgZG9jdW1lbnQuZmlsZS5hcnJheUJ1ZmZlcigpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vcGRmJyB9KVxuICB9XG59XG4iXSwibmFtZXMiOlsicGRmanMiLCJHbG9iYWxXb3JrZXJPcHRpb25zIiwid29ya2VyU3JjIiwicHJvY2Vzc1BERkZpbGUiLCJmaWxlIiwiY29uc29sZSIsImxvZyIsIm5hbWUiLCJzaXplIiwidHlwZSIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsInBkZiIsImdldERvY3VtZW50IiwiZGF0YSIsInZlcmJvc2l0eSIsImNNYXBVcmwiLCJjTWFwUGFja2VkIiwic3RhbmRhcmRGb250RGF0YVVybCIsInN0b3BBdEVycm9ycyIsIm1heEltYWdlU2l6ZSIsImRpc2FibGVGb250RmFjZSIsImRpc2FibGVSYW5nZSIsImRpc2FibGVTdHJlYW0iLCJwcm9taXNlIiwibnVtUGFnZXMiLCJwYWdlcyIsImkiLCJwYWdlIiwiZ2V0UGFnZSIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJzY2FsZSIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJnZXRDb250ZXh0IiwiaGVpZ2h0Iiwid2lkdGgiLCJyZW5kZXIiLCJjYW52YXNDb250ZXh0IiwiaW50ZW50IiwidHJhbnNmb3JtIiwiYmFja2dyb3VuZCIsInRodW1ibmFpbCIsInRvRGF0YVVSTCIsInB1c2giLCJpZCIsInBhZ2VOdW1iZXIiLCJpc1NlbGVjdGVkIiwiaXNDb3ZlciIsInBhZ2VFcnJvciIsIndhcm4iLCJsZW5ndGgiLCJEYXRlIiwibm93IiwidG90YWxQYWdlcyIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiZGV0ZWN0Q292ZXJQYWdlcyIsImZpbHRlciIsImluZGV4IiwibWFwIiwicmVuZGVyUERGUGFnZUhpZ2hSZXMiLCJleHBvcnRQREYiLCJzZWxlY3RlZFBhZ2VzIiwiQmxvYiIsIlBERkRvY3VtZW50IiwiUERGTGliRG9jdW1lbnQiLCJleGlzdGluZ1BkZkJ5dGVzIiwicGRmRG9jIiwibG9hZCIsIm5ld1BkZiIsImNyZWF0ZSIsInNlbGVjdGVkUGFnZU51bWJlcnMiLCJwYWdlSWQiLCJmaW5kIiwicCIsIm51bSIsInNvcnQiLCJhIiwiYiIsImNvcGllZFBhZ2VzIiwiY29weVBhZ2VzIiwiZm9yRWFjaCIsImFkZFBhZ2UiLCJwZGZCeXRlcyIsInNhdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pdf-utils.ts\n"));

/***/ })

});