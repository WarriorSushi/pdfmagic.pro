"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/pdf-utils.ts":
/*!******************************!*\
  !*** ./src/lib/pdf-utils.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectCoverPages: function() { return /* binding */ detectCoverPages; },\n/* harmony export */   exportPDF: function() { return /* binding */ exportPDF; },\n/* harmony export */   processPDFFile: function() { return /* binding */ processPDFFile; },\n/* harmony export */   renderPDFPageHighRes: function() { return /* binding */ renderPDFPageHighRes; }\n/* harmony export */ });\n/* harmony import */ var react_pdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-pdf */ \"(app-pages-browser)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.mjs\");\n\n// Configure PDF.js worker to match react-pdf's internal pdfjs-dist@5.3.93\nreact_pdf__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.mjs\";\nasync function processPDFFile(file) {\n    try {\n        console.log(\"Processing PDF:\", file.name, \"Size:\", file.size, \"Type:\", file.type);\n        const arrayBuffer = await file.arrayBuffer();\n        console.log(\"ArrayBuffer size:\", arrayBuffer.byteLength);\n        const pdf = await react_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            // Enhanced compatibility options\n            verbosity: 0,\n            cMapUrl: \"https://unpkg.com/pdfjs-dist@3.11.174/cmaps/\",\n            cMapPacked: true,\n            standardFontDataUrl: \"https://unpkg.com/pdfjs-dist@3.11.174/standard_fonts/\",\n            // Handle corrupted PDFs\n            stopAtErrors: false,\n            maxImageSize: 1024 * 1024 * 50,\n            disableFontFace: false,\n            disableRange: false,\n            disableStream: false\n        }).promise;\n        console.log(\"PDF loaded successfully. Pages:\", pdf.numPages);\n        const pages = [];\n        for(let i = 1; i <= pdf.numPages; i++){\n            try {\n                console.log(\"Processing page \".concat(i, \"/\").concat(pdf.numPages));\n                const page = await pdf.getPage(i);\n                const viewport = page.getViewport({\n                    scale: 0.5\n                });\n                const canvas = document.createElement(\"canvas\");\n                const context = canvas.getContext(\"2d\");\n                canvas.height = viewport.height;\n                canvas.width = viewport.width;\n                await page.render({\n                    canvasContext: context,\n                    viewport: viewport,\n                    // Enhanced rendering options for compatibility\n                    intent: \"display\",\n                    renderInteractiveForms: false,\n                    transform: null,\n                    background: \"white\"\n                }).promise;\n                const thumbnail = canvas.toDataURL(\"image/jpeg\", 0.8);\n                pages.push({\n                    id: \"page-\".concat(i),\n                    pageNumber: i,\n                    thumbnail,\n                    isSelected: false,\n                    isCover: i <= 3 // Mark first 3 pages as potential covers\n                });\n            } catch (pageError) {\n                console.warn(\"Failed to process page \".concat(i, \":\"), pageError);\n                // Create a placeholder page for failed pages\n                pages.push({\n                    id: \"page-\".concat(i),\n                    pageNumber: i,\n                    thumbnail: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkVycm9yIExvYWRpbmcgUGFnZTwvdGV4dD48L3N2Zz4=\",\n                    isSelected: false,\n                    isCover: i <= 3\n                });\n            }\n        }\n        console.log(\"Successfully processed\", pages.length, \"pages\");\n        return {\n            id: \"doc-\".concat(Date.now()),\n            name: file.name,\n            file,\n            pages,\n            totalPages: pdf.numPages\n        };\n    } catch (error) {\n        console.error(\"Failed to process PDF file:\", error);\n        throw new Error(\"Failed to load PDF: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n    }\n}\nfunction detectCoverPages(pages) {\n    // Simple heuristic: first 1-3 pages are likely covers\n    return pages.filter((page, index)=>index < 3).map((page)=>page.id);\n}\n// Render a specific PDF page at high resolution for editing\nasync function renderPDFPageHighRes(file, pageNumber) {\n    let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    try {\n        const arrayBuffer = await file.arrayBuffer();\n        const pdf = await react_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            verbosity: 0,\n            stopAtErrors: false\n        }).promise;\n        const page = await pdf.getPage(pageNumber);\n        const viewport = page.getViewport({\n            scale\n        });\n        const canvas = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        canvas.height = viewport.height;\n        canvas.width = viewport.width;\n        await page.render({\n            canvasContext: context,\n            viewport: viewport,\n            intent: \"display\",\n            renderInteractiveForms: false,\n            background: \"white\"\n        }).promise;\n        return canvas.toDataURL(\"image/png\", 1.0);\n    } catch (error) {\n        console.error(\"Failed to render high-res page:\", error);\n        // Return a placeholder image\n        return \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAwIiBoZWlnaHQ9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjlmYWZiIiBzdHJva2U9IiNlNWU3ZWIiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM2Yjc0ODUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5FcnJvciBMb2FkaW5nIFBhZ2U8L3RleHQ+PC9zdmc+\";\n    }\n}\nasync function exportPDF(document1, selectedPages) {\n    try {\n        if (selectedPages.length === 0) {\n            // No pages selected, return original file\n            return new Blob([\n                await document1.file.arrayBuffer()\n            ], {\n                type: \"application/pdf\"\n            });\n        }\n        // Import pdf-lib for PDF manipulation\n        const { PDFDocument: PDFLibDocument } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! pdf-lib */ \"(app-pages-browser)/./node_modules/pdf-lib/es/index.js\"));\n        // Load the original PDF\n        const existingPdfBytes = await document1.file.arrayBuffer();\n        const pdfDoc = await PDFLibDocument.load(existingPdfBytes);\n        // Create a new PDF with only selected pages\n        const newPdf = await PDFLibDocument.create();\n        // Get page numbers from selected page IDs\n        const selectedPageNumbers = selectedPages.map((pageId)=>{\n            const page = document1.pages.find((p)=>p.id === pageId);\n            return page ? page.pageNumber - 1 : -1 // Convert to 0-based index\n            ;\n        }).filter((num)=>num >= 0).sort((a, b)=>a - b);\n        // Copy selected pages to new PDF\n        const copiedPages = await newPdf.copyPages(pdfDoc, selectedPageNumbers);\n        copiedPages.forEach((page)=>newPdf.addPage(page));\n        // Save the new PDF\n        const pdfBytes = await newPdf.save();\n        return new Blob([\n            pdfBytes\n        ], {\n            type: \"application/pdf\"\n        });\n    } catch (error) {\n        console.error(\"Failed to export PDF:\", error);\n        // Fallback: return original file\n        return new Blob([\n            await document1.file.arrayBuffer()\n        ], {\n            type: \"application/pdf\"\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHLEVBQUU7WUFBRUQsTUFBTTtRQUFrQjtJQUNqRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvcGRmLXV0aWxzLnRzP2IzNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGRmanMgfSBmcm9tICdyZWFjdC1wZGYnXG5pbXBvcnQgeyBQREZEb2N1bWVudCwgUERGUGFnZSB9IGZyb20gJ0Avc3RvcmVzL3BkZi1zdG9yZSdcblxuLy8gQ29uZmlndXJlIFBERi5qcyB3b3JrZXIgdG8gbWF0Y2ggcmVhY3QtcGRmJ3MgaW50ZXJuYWwgcGRmanMtZGlzdEA1LjMuOTNcbnBkZmpzLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gJy9wZGYud29ya2VyLm1pbi5tanMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUERGRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTxQREZEb2N1bWVudD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIFBERjonLCBmaWxlLm5hbWUsICdTaXplOicsIGZpbGUuc2l6ZSwgJ1R5cGU6JywgZmlsZS50eXBlKVxuICAgIFxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpXG4gICAgY29uc29sZS5sb2coJ0FycmF5QnVmZmVyIHNpemU6JywgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aClcbiAgICBcbiAgICBjb25zdCBwZGYgPSBhd2FpdCBwZGZqcy5nZXREb2N1bWVudCh7IFxuICAgICAgZGF0YTogYXJyYXlCdWZmZXIsXG4gICAgICAvLyBFbmhhbmNlZCBjb21wYXRpYmlsaXR5IG9wdGlvbnNcbiAgICAgIHZlcmJvc2l0eTogMCwgLy8gUmVkdWNlIGNvbnNvbGUgc3BhbVxuICAgICAgY01hcFVybDogJ2h0dHBzOi8vdW5wa2cuY29tL3BkZmpzLWRpc3RAMy4xMS4xNzQvY21hcHMvJyxcbiAgICAgIGNNYXBQYWNrZWQ6IHRydWUsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsOiAnaHR0cHM6Ly91bnBrZy5jb20vcGRmanMtZGlzdEAzLjExLjE3NC9zdGFuZGFyZF9mb250cy8nLFxuICAgICAgLy8gSGFuZGxlIGNvcnJ1cHRlZCBQREZzXG4gICAgICBzdG9wQXRFcnJvcnM6IGZhbHNlLFxuICAgICAgbWF4SW1hZ2VTaXplOiAxMDI0ICogMTAyNCAqIDUwLCAvLyA1ME1CIG1heCBpbWFnZSBzaXplXG4gICAgICBkaXNhYmxlRm9udEZhY2U6IGZhbHNlLFxuICAgICAgZGlzYWJsZVJhbmdlOiBmYWxzZSxcbiAgICAgIGRpc2FibGVTdHJlYW06IGZhbHNlXG4gICAgfSkucHJvbWlzZVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQREYgbG9hZGVkIHN1Y2Nlc3NmdWxseS4gUGFnZXM6JywgcGRmLm51bVBhZ2VzKVxuICBcbiAgICBjb25zdCBwYWdlczogUERGUGFnZVtdID0gW11cbiAgICBcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBwZGYubnVtUGFnZXM7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgcGFnZSAke2l9LyR7cGRmLm51bVBhZ2VzfWApXG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShpKVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMC41IH0pXG4gICAgICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHRcbiAgICAgICAgY2FudmFzLndpZHRoID0gdmlld3BvcnQud2lkdGhcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHBhZ2UucmVuZGVyKHtcbiAgICAgICAgICBjYW52YXNDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgICAgICAvLyBFbmhhbmNlZCByZW5kZXJpbmcgb3B0aW9ucyBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgIGludGVudDogJ2Rpc3BsYXknLFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IGZhbHNlLFxuICAgICAgICAgIHRyYW5zZm9ybTogbnVsbCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnd2hpdGUnXG4gICAgICAgIH0pLnByb21pc2VcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRodW1ibmFpbCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjgpXG4gICAgICAgIFxuICAgICAgICBwYWdlcy5wdXNoKHtcbiAgICAgICAgICBpZDogYHBhZ2UtJHtpfWAsXG4gICAgICAgICAgcGFnZU51bWJlcjogaSxcbiAgICAgICAgICB0aHVtYm5haWwsXG4gICAgICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgaXNDb3ZlcjogaSA8PSAzIC8vIE1hcmsgZmlyc3QgMyBwYWdlcyBhcyBwb3RlbnRpYWwgY292ZXJzXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAocGFnZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHByb2Nlc3MgcGFnZSAke2l9OmAsIHBhZ2VFcnJvcilcbiAgICAgICAgLy8gQ3JlYXRlIGEgcGxhY2Vob2xkZXIgcGFnZSBmb3IgZmFpbGVkIHBhZ2VzXG4gICAgICAgIHBhZ2VzLnB1c2goe1xuICAgICAgICAgIGlkOiBgcGFnZS0ke2l9YCxcbiAgICAgICAgICBwYWdlTnVtYmVyOiBpLFxuICAgICAgICAgIHRodW1ibmFpbDogJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakk0TUNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNtVmpkQ0IzYVdSMGFEMGlNVEF3SlNJZ2FHVnBaMmgwUFNJeE1EQWxJaUJtYVd4c1BTSWpaak5tTkdZMklpOCtQSFJsZUhRZ2VEMGlOVEFsSWlCNVBTSTFNQ1VpSUdadmJuUXRabUZ0YVd4NVBTSkJjbWxoYkNJZ1ptOXVkQzF6YVhwbFBTSXhOQ0lnWm1sc2JEMGlJelkyTnpNNE5TSWdkR1Y0ZEMxaGJtTm9iM0k5SW0xcFpHUnNaU0lnWkhrOUlpNHpaVzBpUGtWeWNtOXlJRXh2WVdScGJtY2dVR0ZuWlR3dmRHVjRkRDQ4TDNOMlp6ND0nLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGlzQ292ZXI6IGkgPD0gM1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBwcm9jZXNzZWQnLCBwYWdlcy5sZW5ndGgsICdwYWdlcycpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgZG9jLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgZmlsZSxcbiAgICAgIHBhZ2VzLFxuICAgICAgdG90YWxQYWdlczogcGRmLm51bVBhZ2VzXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIFBERiBmaWxlOicsIGVycm9yKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgUERGOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdENvdmVyUGFnZXMocGFnZXM6IFBERlBhZ2VbXSk6IHN0cmluZ1tdIHtcbiAgLy8gU2ltcGxlIGhldXJpc3RpYzogZmlyc3QgMS0zIHBhZ2VzIGFyZSBsaWtlbHkgY292ZXJzXG4gIHJldHVybiBwYWdlc1xuICAgIC5maWx0ZXIoKHBhZ2UsIGluZGV4KSA9PiBpbmRleCA8IDMpXG4gICAgLm1hcChwYWdlID0+IHBhZ2UuaWQpXG59XG5cbi8vIFJlbmRlciBhIHNwZWNpZmljIFBERiBwYWdlIGF0IGhpZ2ggcmVzb2x1dGlvbiBmb3IgZWRpdGluZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlclBERlBhZ2VIaWdoUmVzKGZpbGU6IEZpbGUsIHBhZ2VOdW1iZXI6IG51bWJlciwgc2NhbGU6IG51bWJlciA9IDIpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpXG4gICAgY29uc3QgcGRmID0gYXdhaXQgcGRmanMuZ2V0RG9jdW1lbnQoeyBcbiAgICAgIGRhdGE6IGFycmF5QnVmZmVyLFxuICAgICAgdmVyYm9zaXR5OiAwLFxuICAgICAgc3RvcEF0RXJyb3JzOiBmYWxzZVxuICAgIH0pLnByb21pc2VcbiAgICBcbiAgICBjb25zdCBwYWdlID0gYXdhaXQgcGRmLmdldFBhZ2UocGFnZU51bWJlcilcbiAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZSB9KVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIVxuICAgIGNhbnZhcy5oZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHRcbiAgICBjYW52YXMud2lkdGggPSB2aWV3cG9ydC53aWR0aFxuICAgIFxuICAgIGF3YWl0IHBhZ2UucmVuZGVyKHtcbiAgICAgIGNhbnZhc0NvbnRleHQ6IGNvbnRleHQsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBpbnRlbnQ6ICdkaXNwbGF5JyxcbiAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IGZhbHNlLFxuICAgICAgYmFja2dyb3VuZDogJ3doaXRlJ1xuICAgIH0pLnByb21pc2VcbiAgICBcbiAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJywgMS4wKVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgaGlnaC1yZXMgcGFnZTonLCBlcnJvcilcbiAgICAvLyBSZXR1cm4gYSBwbGFjZWhvbGRlciBpbWFnZVxuICAgIHJldHVybiAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTmpBd0lpQm9aV2xuYUhROUlqZ3dNQ0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JajQ4Y21WamRDQjNhV1IwYUQwaU1UQXdKU0lnYUdWcFoyaDBQU0l4TURBbElpQm1hV3hzUFNJalpqbG1ZV1ppSWlCemRISnZhMlU5SWlObE5XVTNaV0lpSUhOMGNtOXJaUzEzYVdSMGFEMGlNaUl2UGp4MFpYaDBJSGc5SWpVd0pTSWdlVDBpTlRBbElpQm1iMjUwTFdaaGJXbHNlVDBpUVhKcFlXd2lJR1p2Ym5RdGMybDZaVDBpTWpRaUlHWnBiR3c5SWlNMllqYzBPRFVpSUhSbGVIUXRZVzVqYUc5eVBTSnRhV1JrYkdVaUlHUjVQU0l1TTJWdElqNUZjbkp2Y2lCTWIyRmthVzVuSUZCaFoyVThMM1JsZUhRK1BDOXpkbWMrJ1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBvcnRQREYoZG9jdW1lbnQ6IFBERkRvY3VtZW50LCBzZWxlY3RlZFBhZ2VzOiBzdHJpbmdbXSk6IFByb21pc2U8QmxvYj4ge1xuICB0cnkge1xuICAgIGlmIChzZWxlY3RlZFBhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm8gcGFnZXMgc2VsZWN0ZWQsIHJldHVybiBvcmlnaW5hbCBmaWxlXG4gICAgICByZXR1cm4gbmV3IEJsb2IoW2F3YWl0IGRvY3VtZW50LmZpbGUuYXJyYXlCdWZmZXIoKV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfSlcbiAgICB9XG5cbiAgICAvLyBJbXBvcnQgcGRmLWxpYiBmb3IgUERGIG1hbmlwdWxhdGlvblxuICAgIGNvbnN0IHsgUERGRG9jdW1lbnQ6IFBERkxpYkRvY3VtZW50IH0gPSBhd2FpdCBpbXBvcnQoJ3BkZi1saWInKVxuICAgIFxuICAgIC8vIExvYWQgdGhlIG9yaWdpbmFsIFBERlxuICAgIGNvbnN0IGV4aXN0aW5nUGRmQnl0ZXMgPSBhd2FpdCBkb2N1bWVudC5maWxlLmFycmF5QnVmZmVyKClcbiAgICBjb25zdCBwZGZEb2MgPSBhd2FpdCBQREZMaWJEb2N1bWVudC5sb2FkKGV4aXN0aW5nUGRmQnl0ZXMpXG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IFBERiB3aXRoIG9ubHkgc2VsZWN0ZWQgcGFnZXNcbiAgICBjb25zdCBuZXdQZGYgPSBhd2FpdCBQREZMaWJEb2N1bWVudC5jcmVhdGUoKVxuICAgIFxuICAgIC8vIEdldCBwYWdlIG51bWJlcnMgZnJvbSBzZWxlY3RlZCBwYWdlIElEc1xuICAgIGNvbnN0IHNlbGVjdGVkUGFnZU51bWJlcnMgPSBzZWxlY3RlZFBhZ2VzXG4gICAgICAubWFwKHBhZ2VJZCA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBkb2N1bWVudC5wYWdlcy5maW5kKHAgPT4gcC5pZCA9PT0gcGFnZUlkKVxuICAgICAgICByZXR1cm4gcGFnZSA/IHBhZ2UucGFnZU51bWJlciAtIDEgOiAtMSAvLyBDb252ZXJ0IHRvIDAtYmFzZWQgaW5kZXhcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKG51bSA9PiBudW0gPj0gMClcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBcbiAgICAvLyBDb3B5IHNlbGVjdGVkIHBhZ2VzIHRvIG5ldyBQREZcbiAgICBjb25zdCBjb3BpZWRQYWdlcyA9IGF3YWl0IG5ld1BkZi5jb3B5UGFnZXMocGRmRG9jLCBzZWxlY3RlZFBhZ2VOdW1iZXJzKVxuICAgIGNvcGllZFBhZ2VzLmZvckVhY2gocGFnZSA9PiBuZXdQZGYuYWRkUGFnZShwYWdlKSlcbiAgICBcbiAgICAvLyBTYXZlIHRoZSBuZXcgUERGXG4gICAgY29uc3QgcGRmQnl0ZXMgPSBhd2FpdCBuZXdQZGYuc2F2ZSgpXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtwZGZCeXRlc10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfSlcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZXhwb3J0IFBERjonLCBlcnJvcilcbiAgICAvLyBGYWxsYmFjazogcmV0dXJuIG9yaWdpbmFsIGZpbGVcbiAgICByZXR1cm4gbmV3IEJsb2IoW2F3YWl0IGRvY3VtZW50LmZpbGUuYXJyYXlCdWZmZXIoKV0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbInBkZmpzIiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIndvcmtlclNyYyIsInByb2Nlc3NQREZGaWxlIiwiZmlsZSIsImNvbnNvbGUiLCJsb2ciLCJuYW1lIiwic2l6ZSIsInR5cGUiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJwZGYiLCJnZXREb2N1bWVudCIsImRhdGEiLCJ2ZXJib3NpdHkiLCJjTWFwVXJsIiwiY01hcFBhY2tlZCIsInN0YW5kYXJkRm9udERhdGFVcmwiLCJzdG9wQXRFcnJvcnMiLCJtYXhJbWFnZVNpemUiLCJkaXNhYmxlRm9udEZhY2UiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwicHJvbWlzZSIsIm51bVBhZ2VzIiwicGFnZXMiLCJpIiwicGFnZSIsImdldFBhZ2UiLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0Iiwic2NhbGUiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImhlaWdodCIsIndpZHRoIiwicmVuZGVyIiwiY2FudmFzQ29udGV4dCIsImludGVudCIsInJlbmRlckludGVyYWN0aXZlRm9ybXMiLCJ0cmFuc2Zvcm0iLCJiYWNrZ3JvdW5kIiwidGh1bWJuYWlsIiwidG9EYXRhVVJMIiwicHVzaCIsImlkIiwicGFnZU51bWJlciIsImlzU2VsZWN0ZWQiLCJpc0NvdmVyIiwicGFnZUVycm9yIiwid2FybiIsImxlbmd0aCIsIkRhdGUiLCJub3ciLCJ0b3RhbFBhZ2VzIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJkZXRlY3RDb3ZlclBhZ2VzIiwiZmlsdGVyIiwiaW5kZXgiLCJtYXAiLCJyZW5kZXJQREZQYWdlSGlnaFJlcyIsImV4cG9ydFBERiIsInNlbGVjdGVkUGFnZXMiLCJCbG9iIiwiUERGRG9jdW1lbnQiLCJQREZMaWJEb2N1bWVudCIsImV4aXN0aW5nUGRmQnl0ZXMiLCJwZGZEb2MiLCJsb2FkIiwibmV3UGRmIiwiY3JlYXRlIiwic2VsZWN0ZWRQYWdlTnVtYmVycyIsInBhZ2VJZCIsImZpbmQiLCJwIiwibnVtIiwic29ydCIsImEiLCJiIiwiY29waWVkUGFnZXMiLCJjb3B5UGFnZXMiLCJmb3JFYWNoIiwiYWRkUGFnZSIsInBkZkJ5dGVzIiwic2F2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pdf-utils.ts\n"));

/***/ })

});