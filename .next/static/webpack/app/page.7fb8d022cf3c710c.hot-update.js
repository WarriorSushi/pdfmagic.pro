"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/pdf-utils.ts":
/*!******************************!*\
  !*** ./src/lib/pdf-utils.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectCoverPages: function() { return /* binding */ detectCoverPages; },\n/* harmony export */   exportPDF: function() { return /* binding */ exportPDF; },\n/* harmony export */   processPDFFile: function() { return /* binding */ processPDFFile; },\n/* harmony export */   renderPDFPageHighRes: function() { return /* binding */ renderPDFPageHighRes; }\n/* harmony export */ });\n/* harmony import */ var react_pdf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-pdf */ \"(app-pages-browser)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.mjs\");\n\n// Configure PDF.js worker to match react-pdf's internal pdfjs-dist@5.3.93\nreact_pdf__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.mjs\";\nasync function processPDFFile(file) {\n    try {\n        console.log(\"Processing PDF:\", file.name, \"Size:\", file.size, \"Type:\", file.type);\n        const arrayBuffer = await file.arrayBuffer();\n        console.log(\"ArrayBuffer size:\", arrayBuffer.byteLength);\n        const pdf = await react_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            // Enhanced compatibility options\n            verbosity: 0,\n            cMapUrl: \"https://unpkg.com/pdfjs-dist@3.11.174/cmaps/\",\n            cMapPacked: true,\n            standardFontDataUrl: \"https://unpkg.com/pdfjs-dist@3.11.174/standard_fonts/\",\n            // Handle corrupted PDFs\n            stopAtErrors: false,\n            maxImageSize: 1024 * 1024 * 50,\n            disableFontFace: false,\n            disableRange: false,\n            disableStream: false\n        }).promise;\n        console.log(\"PDF loaded successfully. Pages:\", pdf.numPages);\n        const pages = [];\n        for(let i = 1; i <= pdf.numPages; i++){\n            try {\n                console.log(\"Processing page \".concat(i, \"/\").concat(pdf.numPages));\n                const page = await pdf.getPage(i);\n                const viewport = page.getViewport({\n                    scale: 0.5\n                });\n                const canvas = document.createElement(\"canvas\");\n                const context = canvas.getContext(\"2d\");\n                canvas.height = viewport.height;\n                canvas.width = viewport.width;\n                await page.render({\n                    canvasContext: context,\n                    viewport: viewport,\n                    // Enhanced rendering options for compatibility\n                    intent: \"display\",\n                    transform: null,\n                    background: \"white\"\n                }).promise;\n                const thumbnail = canvas.toDataURL(\"image/jpeg\", 0.8);\n                pages.push({\n                    id: \"page-\".concat(i),\n                    pageNumber: i,\n                    thumbnail,\n                    isSelected: false,\n                    isCover: i <= 3 // Mark first 3 pages as potential covers\n                });\n            } catch (pageError) {\n                console.warn(\"Failed to process page \".concat(i, \":\"), pageError);\n                // Create a placeholder page for failed pages\n                pages.push({\n                    id: \"page-\".concat(i),\n                    pageNumber: i,\n                    thumbnail: \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkVycm9yIExvYWRpbmcgUGFnZTwvdGV4dD48L3N2Zz4=\",\n                    isSelected: false,\n                    isCover: i <= 3\n                });\n            }\n        }\n        console.log(\"Successfully processed\", pages.length, \"pages\");\n        return {\n            id: \"doc-\".concat(Date.now()),\n            name: file.name,\n            file,\n            pages,\n            totalPages: pdf.numPages\n        };\n    } catch (error) {\n        console.error(\"Failed to process PDF file:\", error);\n        throw new Error(\"Failed to load PDF: \".concat(error instanceof Error ? error.message : \"Unknown error\"));\n    }\n}\nfunction detectCoverPages(pages) {\n    // Simple heuristic: first 1-3 pages are likely covers\n    return pages.filter((page, index)=>index < 3).map((page)=>page.id);\n}\n// Render a specific PDF page at high resolution for editing\nasync function renderPDFPageHighRes(file, pageNumber) {\n    let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    try {\n        const arrayBuffer = await file.arrayBuffer();\n        const pdf = await react_pdf__WEBPACK_IMPORTED_MODULE_0__.getDocument({\n            data: arrayBuffer,\n            verbosity: 0,\n            stopAtErrors: false\n        }).promise;\n        const page = await pdf.getPage(pageNumber);\n        const viewport = page.getViewport({\n            scale\n        });\n        const canvas = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        canvas.height = viewport.height;\n        canvas.width = viewport.width;\n        await page.render({\n            canvasContext: context,\n            viewport: viewport,\n            intent: \"display\",\n            background: \"white\"\n        }).promise;\n        return canvas.toDataURL(\"image/png\", 1.0);\n    } catch (error) {\n        console.error(\"Failed to render high-res page:\", error);\n        // Return a placeholder image\n        return \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAwIiBoZWlnaHQ9IjgwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjlmYWZiIiBzdHJva2U9IiNlNWU3ZWIiIHN0cm9rZS13aWR0aD0iMiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiM2Yjc0ODUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5FcnJvciBMb2FkaW5nIFBhZ2U8L3RleHQ+PC9zdmc+\";\n    }\n}\nasync function exportPDF(document1, selectedPages) {\n    try {\n        // Import pdf-lib for PDF manipulation\n        const { PDFDocument: PDFLibDocument, rgb } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! pdf-lib */ \"(app-pages-browser)/./node_modules/pdf-lib/es/index.js\"));\n        // Load the original PDF\n        const existingPdfBytes = await document1.file.arrayBuffer();\n        const pdfDoc = await PDFLibDocument.load(existingPdfBytes);\n        // Create a new PDF\n        const newPdf = await PDFLibDocument.create();\n        // Determine which pages to export\n        const pagesToExport = selectedPages.length === 0 ? document1.pages // Export all pages if none selected\n         : document1.pages.filter((p)=>selectedPages.includes(p.id));\n        // Process each page\n        for (const pageData of pagesToExport){\n            const pageIndex = pageData.pageNumber - 1;\n            if (pageData.editedDataUrl) {\n                // Use edited version\n                try {\n                    const imgBytes = await (await fetch(pageData.editedDataUrl)).arrayBuffer();\n                    const isPng = pageData.editedDataUrl.startsWith(\"data:image/png\");\n                    const embedded = isPng ? await newPdf.embedPng(imgBytes) : await newPdf.embedJpg(imgBytes);\n                    // Get original page dimensions\n                    const originalPage = pdfDoc.getPage(pageIndex);\n                    const { width, height } = originalPage.getSize();\n                    // Create new page with same dimensions\n                    const newPage = newPdf.addPage([\n                        width,\n                        height\n                    ]);\n                    // Draw white background\n                    newPage.drawRectangle({\n                        x: 0,\n                        y: 0,\n                        width,\n                        height,\n                        color: rgb(1, 1, 1)\n                    });\n                    // Draw edited image\n                    newPage.drawImage(embedded, {\n                        x: 0,\n                        y: 0,\n                        width,\n                        height\n                    });\n                } catch (error) {\n                    console.error(\"Failed to embed edited page, using original:\", error);\n                    // Fallback to original page\n                    const [copiedPage] = await newPdf.copyPages(pdfDoc, [\n                        pageIndex\n                    ]);\n                    newPdf.addPage(copiedPage);\n                }\n            } else {\n                // Use original page\n                const [copiedPage] = await newPdf.copyPages(pdfDoc, [\n                    pageIndex\n                ]);\n                newPdf.addPage(copiedPage);\n            }\n        }\n        // Save the new PDF\n        const pdfBytes = await newPdf.save();\n        return new Blob([\n            pdfBytes\n        ], {\n            type: \"application/pdf\"\n        });\n    } catch (error) {\n        console.error(\"Failed to export PDF:\", error);\n        // Fallback: return original file\n        return new Blob([\n            await document1.file.arrayBuffer()\n        ], {\n            type: \"application/pdf\"\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFvQjtvQkFDcEJxQixRQUFRTSxTQUFTLENBQUNYLFVBQVU7d0JBQUVRLEdBQUc7d0JBQUdDLEdBQUc7d0JBQUd4RDt3QkFBT0Q7b0JBQU87Z0JBQzFELEVBQUUsT0FBT29CLE9BQU87b0JBQ2RyRCxRQUFRcUQsS0FBSyxDQUFDLGdEQUFnREE7b0JBQzlELDRCQUE0QjtvQkFDNUIsTUFBTSxDQUFDd0MsV0FBVyxHQUFHLE1BQU14QixPQUFPeUIsU0FBUyxDQUFDM0IsUUFBUTt3QkFBQ1E7cUJBQVU7b0JBQy9ETixPQUFPa0IsT0FBTyxDQUFDTTtnQkFDakI7WUFDRixPQUFPO2dCQUNMLG9CQUFvQjtnQkFDcEIsTUFBTSxDQUFDQSxXQUFXLEdBQUcsTUFBTXhCLE9BQU95QixTQUFTLENBQUMzQixRQUFRO29CQUFDUTtpQkFBVTtnQkFDL0ROLE9BQU9rQixPQUFPLENBQUNNO1lBQ2pCO1FBQ0Y7UUFFQSxtQkFBbUI7UUFDbkIsTUFBTUUsV0FBVyxNQUFNMUIsT0FBTzJCLElBQUk7UUFDbEMsT0FBTyxJQUFJQyxLQUFLO1lBQUNGO1NBQVMsRUFBRTtZQUFFM0YsTUFBTTtRQUFrQjtJQUV4RCxFQUFFLE9BQU9pRCxPQUFPO1FBQ2RyRCxRQUFRcUQsS0FBSyxDQUFDLHlCQUF5QkE7UUFDdkMsaUNBQWlDO1FBQ2pDLE9BQU8sSUFBSTRDLEtBQUs7WUFBQyxNQUFNcEUsVUFBUzlCLElBQUksQ0FBQ00sV0FBVztTQUFHLEVBQUU7WUFBRUQsTUFBTTtRQUFrQjtJQUNqRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvcGRmLXV0aWxzLnRzP2IzNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGRmanMgfSBmcm9tICdyZWFjdC1wZGYnXG5pbXBvcnQgeyBQREZEb2N1bWVudCwgUERGUGFnZSB9IGZyb20gJ0Avc3RvcmVzL3BkZi1zdG9yZSdcblxuLy8gQ29uZmlndXJlIFBERi5qcyB3b3JrZXIgdG8gbWF0Y2ggcmVhY3QtcGRmJ3MgaW50ZXJuYWwgcGRmanMtZGlzdEA1LjMuOTNcbnBkZmpzLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gJy9wZGYud29ya2VyLm1pbi5tanMnXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzUERGRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTxQREZEb2N1bWVudD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIFBERjonLCBmaWxlLm5hbWUsICdTaXplOicsIGZpbGUuc2l6ZSwgJ1R5cGU6JywgZmlsZS50eXBlKVxuICAgIFxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpXG4gICAgY29uc29sZS5sb2coJ0FycmF5QnVmZmVyIHNpemU6JywgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aClcbiAgICBcbiAgICBjb25zdCBwZGYgPSBhd2FpdCBwZGZqcy5nZXREb2N1bWVudCh7IFxuICAgICAgZGF0YTogYXJyYXlCdWZmZXIsXG4gICAgICAvLyBFbmhhbmNlZCBjb21wYXRpYmlsaXR5IG9wdGlvbnNcbiAgICAgIHZlcmJvc2l0eTogMCwgLy8gUmVkdWNlIGNvbnNvbGUgc3BhbVxuICAgICAgY01hcFVybDogJ2h0dHBzOi8vdW5wa2cuY29tL3BkZmpzLWRpc3RAMy4xMS4xNzQvY21hcHMvJyxcbiAgICAgIGNNYXBQYWNrZWQ6IHRydWUsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsOiAnaHR0cHM6Ly91bnBrZy5jb20vcGRmanMtZGlzdEAzLjExLjE3NC9zdGFuZGFyZF9mb250cy8nLFxuICAgICAgLy8gSGFuZGxlIGNvcnJ1cHRlZCBQREZzXG4gICAgICBzdG9wQXRFcnJvcnM6IGZhbHNlLFxuICAgICAgbWF4SW1hZ2VTaXplOiAxMDI0ICogMTAyNCAqIDUwLCAvLyA1ME1CIG1heCBpbWFnZSBzaXplXG4gICAgICBkaXNhYmxlRm9udEZhY2U6IGZhbHNlLFxuICAgICAgZGlzYWJsZVJhbmdlOiBmYWxzZSxcbiAgICAgIGRpc2FibGVTdHJlYW06IGZhbHNlXG4gICAgfSkucHJvbWlzZVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQREYgbG9hZGVkIHN1Y2Nlc3NmdWxseS4gUGFnZXM6JywgcGRmLm51bVBhZ2VzKVxuICBcbiAgICBjb25zdCBwYWdlczogUERGUGFnZVtdID0gW11cbiAgICBcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBwZGYubnVtUGFnZXM7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NpbmcgcGFnZSAke2l9LyR7cGRmLm51bVBhZ2VzfWApXG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShpKVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogMC41IH0pXG4gICAgICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHRcbiAgICAgICAgY2FudmFzLndpZHRoID0gdmlld3BvcnQud2lkdGhcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHBhZ2UucmVuZGVyKHtcbiAgICAgICAgICBjYW52YXNDb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgICAgICAvLyBFbmhhbmNlZCByZW5kZXJpbmcgb3B0aW9ucyBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgIGludGVudDogJ2Rpc3BsYXknLFxuICAgICAgICAgIHRyYW5zZm9ybTogbnVsbCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAnd2hpdGUnXG4gICAgICAgIH0pLnByb21pc2VcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRodW1ibmFpbCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjgpXG4gICAgICAgIFxuICAgICAgICBwYWdlcy5wdXNoKHtcbiAgICAgICAgICBpZDogYHBhZ2UtJHtpfWAsXG4gICAgICAgICAgcGFnZU51bWJlcjogaSxcbiAgICAgICAgICB0aHVtYm5haWwsXG4gICAgICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgaXNDb3ZlcjogaSA8PSAzIC8vIE1hcmsgZmlyc3QgMyBwYWdlcyBhcyBwb3RlbnRpYWwgY292ZXJzXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAocGFnZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHByb2Nlc3MgcGFnZSAke2l9OmAsIHBhZ2VFcnJvcilcbiAgICAgICAgLy8gQ3JlYXRlIGEgcGxhY2Vob2xkZXIgcGFnZSBmb3IgZmFpbGVkIHBhZ2VzXG4gICAgICAgIHBhZ2VzLnB1c2goe1xuICAgICAgICAgIGlkOiBgcGFnZS0ke2l9YCxcbiAgICAgICAgICBwYWdlTnVtYmVyOiBpLFxuICAgICAgICAgIHRodW1ibmFpbDogJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qQXdJaUJvWldsbmFIUTlJakk0TUNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNtVmpkQ0IzYVdSMGFEMGlNVEF3SlNJZ2FHVnBaMmgwUFNJeE1EQWxJaUJtYVd4c1BTSWpaak5tTkdZMklpOCtQSFJsZUhRZ2VEMGlOVEFsSWlCNVBTSTFNQ1VpSUdadmJuUXRabUZ0YVd4NVBTSkJjbWxoYkNJZ1ptOXVkQzF6YVhwbFBTSXhOQ0lnWm1sc2JEMGlJelkyTnpNNE5TSWdkR1Y0ZEMxaGJtTm9iM0k5SW0xcFpHUnNaU0lnWkhrOUlpNHpaVzBpUGtWeWNtOXlJRXh2WVdScGJtY2dVR0ZuWlR3dmRHVjRkRDQ4TDNOMlp6ND0nLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGlzQ292ZXI6IGkgPD0gM1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgXG4gICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBwcm9jZXNzZWQnLCBwYWdlcy5sZW5ndGgsICdwYWdlcycpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBgZG9jLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgZmlsZSxcbiAgICAgIHBhZ2VzLFxuICAgICAgdG90YWxQYWdlczogcGRmLm51bVBhZ2VzXG4gICAgfVxuICAgIFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIFBERiBmaWxlOicsIGVycm9yKVxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgUERGOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdENvdmVyUGFnZXMocGFnZXM6IFBERlBhZ2VbXSk6IHN0cmluZ1tdIHtcbiAgLy8gU2ltcGxlIGhldXJpc3RpYzogZmlyc3QgMS0zIHBhZ2VzIGFyZSBsaWtlbHkgY292ZXJzXG4gIHJldHVybiBwYWdlc1xuICAgIC5maWx0ZXIoKHBhZ2UsIGluZGV4KSA9PiBpbmRleCA8IDMpXG4gICAgLm1hcChwYWdlID0+IHBhZ2UuaWQpXG59XG5cbi8vIFJlbmRlciBhIHNwZWNpZmljIFBERiBwYWdlIGF0IGhpZ2ggcmVzb2x1dGlvbiBmb3IgZWRpdGluZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmRlclBERlBhZ2VIaWdoUmVzKGZpbGU6IEZpbGUsIHBhZ2VOdW1iZXI6IG51bWJlciwgc2NhbGU6IG51bWJlciA9IDIpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpXG4gICAgY29uc3QgcGRmID0gYXdhaXQgcGRmanMuZ2V0RG9jdW1lbnQoeyBcbiAgICAgIGRhdGE6IGFycmF5QnVmZmVyLFxuICAgICAgdmVyYm9zaXR5OiAwLFxuICAgICAgc3RvcEF0RXJyb3JzOiBmYWxzZVxuICAgIH0pLnByb21pc2VcbiAgICBcbiAgICBjb25zdCBwYWdlID0gYXdhaXQgcGRmLmdldFBhZ2UocGFnZU51bWJlcilcbiAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZSB9KVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIVxuICAgIGNhbnZhcy5oZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHRcbiAgICBjYW52YXMud2lkdGggPSB2aWV3cG9ydC53aWR0aFxuICAgIFxuICAgIGF3YWl0IHBhZ2UucmVuZGVyKHtcbiAgICAgIGNhbnZhc0NvbnRleHQ6IGNvbnRleHQsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBpbnRlbnQ6ICdkaXNwbGF5JyxcbiAgICAgIGJhY2tncm91bmQ6ICd3aGl0ZSdcbiAgICB9KS5wcm9taXNlXG4gICAgXG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycsIDEuMClcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVuZGVyIGhpZ2gtcmVzIHBhZ2U6JywgZXJyb3IpXG4gICAgLy8gUmV0dXJuIGEgcGxhY2Vob2xkZXIgaW1hZ2VcbiAgICByZXR1cm4gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5qQXdJaUJvWldsbmFIUTlJamd3TUNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0OGNtVmpkQ0IzYVdSMGFEMGlNVEF3SlNJZ2FHVnBaMmgwUFNJeE1EQWxJaUJtYVd4c1BTSWpaamxtWVdaaUlpQnpkSEp2YTJVOUlpTmxOV1UzWldJaUlITjBjbTlyWlMxM2FXUjBhRDBpTWlJdlBqeDBaWGgwSUhnOUlqVXdKU0lnZVQwaU5UQWxJaUJtYjI1MExXWmhiV2xzZVQwaVFYSnBZV3dpSUdadmJuUXRjMmw2WlQwaU1qUWlJR1pwYkd3OUlpTTJZamMwT0RVaUlIUmxlSFF0WVc1amFHOXlQU0p0YVdSa2JHVWlJR1I1UFNJdU0yVnRJajVGY25KdmNpQk1iMkZrYVc1bklGQmhaMlU4TDNSbGVIUStQQzl6ZG1jKydcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhwb3J0UERGKGRvY3VtZW50OiBQREZEb2N1bWVudCwgc2VsZWN0ZWRQYWdlczogc3RyaW5nW10pOiBQcm9taXNlPEJsb2I+IHtcbiAgdHJ5IHtcbiAgICAvLyBJbXBvcnQgcGRmLWxpYiBmb3IgUERGIG1hbmlwdWxhdGlvblxuICAgIGNvbnN0IHsgUERGRG9jdW1lbnQ6IFBERkxpYkRvY3VtZW50LCByZ2IgfSA9IGF3YWl0IGltcG9ydCgncGRmLWxpYicpXG4gICAgXG4gICAgLy8gTG9hZCB0aGUgb3JpZ2luYWwgUERGXG4gICAgY29uc3QgZXhpc3RpbmdQZGZCeXRlcyA9IGF3YWl0IGRvY3VtZW50LmZpbGUuYXJyYXlCdWZmZXIoKVxuICAgIGNvbnN0IHBkZkRvYyA9IGF3YWl0IFBERkxpYkRvY3VtZW50LmxvYWQoZXhpc3RpbmdQZGZCeXRlcylcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgUERGXG4gICAgY29uc3QgbmV3UGRmID0gYXdhaXQgUERGTGliRG9jdW1lbnQuY3JlYXRlKClcbiAgICBcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggcGFnZXMgdG8gZXhwb3J0XG4gICAgY29uc3QgcGFnZXNUb0V4cG9ydCA9IHNlbGVjdGVkUGFnZXMubGVuZ3RoID09PSAwIFxuICAgICAgPyBkb2N1bWVudC5wYWdlcyAvLyBFeHBvcnQgYWxsIHBhZ2VzIGlmIG5vbmUgc2VsZWN0ZWRcbiAgICAgIDogZG9jdW1lbnQucGFnZXMuZmlsdGVyKHAgPT4gc2VsZWN0ZWRQYWdlcy5pbmNsdWRlcyhwLmlkKSlcbiAgICBcbiAgICAvLyBQcm9jZXNzIGVhY2ggcGFnZVxuICAgIGZvciAoY29uc3QgcGFnZURhdGEgb2YgcGFnZXNUb0V4cG9ydCkge1xuICAgICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZURhdGEucGFnZU51bWJlciAtIDFcbiAgICAgIFxuICAgICAgaWYgKHBhZ2VEYXRhLmVkaXRlZERhdGFVcmwpIHtcbiAgICAgICAgLy8gVXNlIGVkaXRlZCB2ZXJzaW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaW1nQnl0ZXMgPSBhd2FpdCAoYXdhaXQgZmV0Y2gocGFnZURhdGEuZWRpdGVkRGF0YVVybCkpLmFycmF5QnVmZmVyKClcbiAgICAgICAgICBjb25zdCBpc1BuZyA9IHBhZ2VEYXRhLmVkaXRlZERhdGFVcmwuc3RhcnRzV2l0aCgnZGF0YTppbWFnZS9wbmcnKVxuICAgICAgICAgIGNvbnN0IGVtYmVkZGVkID0gaXNQbmcgPyBhd2FpdCBuZXdQZGYuZW1iZWRQbmcoaW1nQnl0ZXMpIDogYXdhaXQgbmV3UGRmLmVtYmVkSnBnKGltZ0J5dGVzKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBvcmlnaW5hbCBwYWdlIGRpbWVuc2lvbnNcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFBhZ2UgPSBwZGZEb2MuZ2V0UGFnZShwYWdlSW5kZXgpXG4gICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcmlnaW5hbFBhZ2UuZ2V0U2l6ZSgpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBwYWdlIHdpdGggc2FtZSBkaW1lbnNpb25zXG4gICAgICAgICAgY29uc3QgbmV3UGFnZSA9IG5ld1BkZi5hZGRQYWdlKFt3aWR0aCwgaGVpZ2h0XSlcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgICBuZXdQYWdlLmRyYXdSZWN0YW5nbGUoeyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0LCBjb2xvcjogcmdiKDEsIDEsIDEpIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyBlZGl0ZWQgaW1hZ2VcbiAgICAgICAgICBuZXdQYWdlLmRyYXdJbWFnZShlbWJlZGRlZCwgeyB4OiAwLCB5OiAwLCB3aWR0aCwgaGVpZ2h0IH0pXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGVtYmVkIGVkaXRlZCBwYWdlLCB1c2luZyBvcmlnaW5hbDonLCBlcnJvcilcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBvcmlnaW5hbCBwYWdlXG4gICAgICAgICAgY29uc3QgW2NvcGllZFBhZ2VdID0gYXdhaXQgbmV3UGRmLmNvcHlQYWdlcyhwZGZEb2MsIFtwYWdlSW5kZXhdKVxuICAgICAgICAgIG5ld1BkZi5hZGRQYWdlKGNvcGllZFBhZ2UpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSBvcmlnaW5hbCBwYWdlXG4gICAgICAgIGNvbnN0IFtjb3BpZWRQYWdlXSA9IGF3YWl0IG5ld1BkZi5jb3B5UGFnZXMocGRmRG9jLCBbcGFnZUluZGV4XSlcbiAgICAgICAgbmV3UGRmLmFkZFBhZ2UoY29waWVkUGFnZSlcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2F2ZSB0aGUgbmV3IFBERlxuICAgIGNvbnN0IHBkZkJ5dGVzID0gYXdhaXQgbmV3UGRmLnNhdmUoKVxuICAgIHJldHVybiBuZXcgQmxvYihbcGRmQnl0ZXNdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9wZGYnIH0pXG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGV4cG9ydCBQREY6JywgZXJyb3IpXG4gICAgLy8gRmFsbGJhY2s6IHJldHVybiBvcmlnaW5hbCBmaWxlXG4gICAgcmV0dXJuIG5ldyBCbG9iKFthd2FpdCBkb2N1bWVudC5maWxlLmFycmF5QnVmZmVyKCldLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9wZGYnIH0pXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJwZGZqcyIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJ3b3JrZXJTcmMiLCJwcm9jZXNzUERGRmlsZSIsImZpbGUiLCJjb25zb2xlIiwibG9nIiwibmFtZSIsInNpemUiLCJ0eXBlIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwicGRmIiwiZ2V0RG9jdW1lbnQiLCJkYXRhIiwidmVyYm9zaXR5IiwiY01hcFVybCIsImNNYXBQYWNrZWQiLCJzdGFuZGFyZEZvbnREYXRhVXJsIiwic3RvcEF0RXJyb3JzIiwibWF4SW1hZ2VTaXplIiwiZGlzYWJsZUZvbnRGYWNlIiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsInByb21pc2UiLCJudW1QYWdlcyIsInBhZ2VzIiwiaSIsInBhZ2UiLCJnZXRQYWdlIiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInNjYWxlIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29udGV4dCIsImdldENvbnRleHQiLCJoZWlnaHQiLCJ3aWR0aCIsInJlbmRlciIsImNhbnZhc0NvbnRleHQiLCJpbnRlbnQiLCJ0cmFuc2Zvcm0iLCJiYWNrZ3JvdW5kIiwidGh1bWJuYWlsIiwidG9EYXRhVVJMIiwicHVzaCIsImlkIiwicGFnZU51bWJlciIsImlzU2VsZWN0ZWQiLCJpc0NvdmVyIiwicGFnZUVycm9yIiwid2FybiIsImxlbmd0aCIsIkRhdGUiLCJub3ciLCJ0b3RhbFBhZ2VzIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJkZXRlY3RDb3ZlclBhZ2VzIiwiZmlsdGVyIiwiaW5kZXgiLCJtYXAiLCJyZW5kZXJQREZQYWdlSGlnaFJlcyIsImV4cG9ydFBERiIsInNlbGVjdGVkUGFnZXMiLCJQREZEb2N1bWVudCIsIlBERkxpYkRvY3VtZW50IiwicmdiIiwiZXhpc3RpbmdQZGZCeXRlcyIsInBkZkRvYyIsImxvYWQiLCJuZXdQZGYiLCJjcmVhdGUiLCJwYWdlc1RvRXhwb3J0IiwicCIsImluY2x1ZGVzIiwicGFnZURhdGEiLCJwYWdlSW5kZXgiLCJlZGl0ZWREYXRhVXJsIiwiaW1nQnl0ZXMiLCJmZXRjaCIsImlzUG5nIiwic3RhcnRzV2l0aCIsImVtYmVkZGVkIiwiZW1iZWRQbmciLCJlbWJlZEpwZyIsIm9yaWdpbmFsUGFnZSIsImdldFNpemUiLCJuZXdQYWdlIiwiYWRkUGFnZSIsImRyYXdSZWN0YW5nbGUiLCJ4IiwieSIsImNvbG9yIiwiZHJhd0ltYWdlIiwiY29waWVkUGFnZSIsImNvcHlQYWdlcyIsInBkZkJ5dGVzIiwic2F2ZSIsIkJsb2IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/pdf-utils.ts\n"));

/***/ })

});